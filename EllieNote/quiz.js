2. What's the output?
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 1);
}

for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 1);
}

Since the variable i in the first loop was declared using the var keyword, this value was global.
During the loop, we incremented the value of i by 1 each time, using the unary operator ++. By the time the setTimeout callback function was invoked,
i was equal to 3 in the first example.

In the second loop, the variable i was declared using the let keyword: variables declared with the let (and const) keyword are block-scoped (a block is anything between { }).
During each iteration, i will have a new value, and each value is scoped inside the loop.



Answer = C: 3 3 3 and 0 1 2

7.
new Number() is a built-in function constructor.
When we use the == operator, it only checks whether it has the same value. They both have the value of 3, so it returns true.
However, when we use the === operator, both value and type should be the same. It's not: new Number() is not a number, it's an object. Both return false.


18.
This is why both { age: 18 } === { age: 18 } and { age: 18 } == { age: 18 } return false.
JavaScript checks if the objects have a reference to the same location in memory.

20.
With "use strict", you can make sure that you don't accidentally declare global variables. 

24.
All object keys (excluding Symbols) are strings under the hood, even if you don't type it yourself as a string. 


28. What's the output?
String.prototype.giveLydiaPizza = () => {
  return 'Just give Lydia pizza already!';
};

const name = 'Lydia';

name.giveLydiaPizza();

A: "Just give Lydia pizza already!"
String is a built-in constructor, which we can add properties to. I just added a method to its prototype. 
Primitive strings are automatically converted into a string object, generated by the string prototype function.
 So, all strings (string objects) have access to that method!


40.
 const red = [[0, 1], [2, 3]].reduce(
  (acc, cur) => {
    return acc.concat(cur);
  },
  [1, 2],
);
console.log(red);

46.
let person = { name: 'Lydia' };
const members = [person];
person = null;

console.log(members);
When you assign a reference from one variable to another,
you make a copy of that reference. (note that they don't have the same reference!)

51.???
82.???
var koGreeting = { 
  greeting : "안녕",
  name : "홍길동", 
  sayHello: function() { 
    return this.greeting + ", " + this.name; } 
  }; 
var enGreeting = { 
    greeting: "Hello",
    name: "HongKilDong" 
  };

  console.log(koGreeting.sayHello()); 
  console.log(koGreeting.sayHello.call(enGreeting)); 
  결과) 안녕, 홍길동 
        Hello, Hong KilDong


100. What's the value of output?
// 🎉✨ This is my 100th question! ✨🎉

const output = `${[] && 'Im'}possible!
You should${'' && `n't`} see a therapist after so much JavaScript lol`;
console.log(output)

[] is a truthy value.
"" is a falsy value. 


108. Which of these methods modifies the original array?
const emojis = ['✨', '🥑', '😍'];

emojis.map(x => x + '✨');   // return a new array
emojis.filter(x => x !== '🥑');  // return a new array : return an array with true values
emojis.find(x => x !== '🥑');  // returns an element : 해당하는 첫번째 값만 찾는다 when the function return true, and end. 
emojis.reduce((acc, cur) => acc + '✨'); // returns a reduced value.
emojis.slice(1, 2, '✨');  // 추출 (index1부터 2전까지(2는 포함안됨)) it dosen't affect the original array = return a new array
emojis.splice(1, 2, '✨'); // 추출 삽입 (index1 부터 2까지 선택) remove 2 items from index 1 and add the ✨ emoji instead. : has an effect on the original array 
emojis.unshift(); // 메서드는 새로운 요소를 배열의 맨 앞쪽에 추가하고, 새로운 길이를 반환합니다.

// set,get
115. Which method(s) will return the value 'Hello world!'?
const myMap = new Map();
const myFunc = () => 'greeting'; //key
          //key     value
myMap.set(myFunc, 'Hello world!'); //Setters don't hold an actual value, their purpose is to modify properties. 

//1
myMap.get('greeting');
//2
myMap.get(myFunc);
//3
myMap.get(() => 'greeting');

// answer : 2
When adding a key/value pair using the set method, the key will be the value of the first argument passed to the set function,
and the value will be the second argument passed to the set function. 
The key is the function () => 'greeting' in this case, and the value 'Hello world'. myMap is now { () => 'greeting' => 'Hello world!' }.

// change an array to number
// we can spread iterables to individual elements.
117. Which of the following options will return 6?
function sumValues(x, y, z) {
  return x + y + z;
}
sumValues(...[1, 2, 3]);

// standard, dollor, 
126. What's the output?
function getFine(speed, amount) {
  const formattedSpeed = new Intl.NumberFormat('en-US', {
    style: 'unit',
    unit: 'mile-per-hour'
  }).format(speed);

  const formattedAmount = new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: 'USD'
  }).format(amount);

  return `The driver drove ${formattedSpeed} and has to pay ${formattedAmount}`;
}

console.log(getFine(130, 300))

// Set,Get
135. What's the output?
const handler = {
  set: () => console.log('Added a new property!'), 
  get: () => console.log('Accessed a property!'), 
};

const person = new Proxy({}, handler); // With a Proxy object, we can add custom behavior to an object that we pass to it as the second argument


person.name = 'Lydia'; //'set' gets invoked whenever we set property values,
person.name; // 'get' gets invoked whenever we get (access) property values.
};

//object seal
136. Which of the following will modify the person object?
const person = { name: 'Lydia Hallie' };

Object.seal(person);
person.name = "Evan Bacon"
console.log(person)
With Object.seal we can prevent new properies from being added, or existing properties to be removed.
However, you can still modify the value of existing properties.

// freeze object
137. Which of the following will modify the person object?
const person = {
  name: 'Lydia Hallie',
  address: {
    street: '100 Main St',
  },
};

Object.freeze(person);
person.address.street = "101 Main St";
The Object.freeze method freezes an object. No properties can be added, modified, or removed.
However, it only shallowly freezes the object, meaning that only direct properties on the object are frozen. If the property is another object,
like address in this case, the properties on that object aren't frozen, and can be modified.

139.
In ES2020, we can add private variables in classes by using the #.

140.  generator object

150. ...object // spread operator ...

151. this in a arrow function 
An arrow function expression is a compact alternative to a traditional function expression, but is limited and can't be used in all situations.
- Does not have its own bindings to this or super, and should not be used as methods.
- Does not have arguments, or new.target keywords.
- Not suitable for call, apply and bind methods, which generally rely on establishing a scope.
- Can not be used as constructors.
- Can not use yield, within its body.

// Test
// Test
// Test
// Test


단어 s의 가운데 글자를 반환하는 함수, solution을 만들어 보세요. 단어의 길이가 짝수라면 가운데 두글자를 반환하면 됩니다.
function solution(s) {
  var answer = '';
  if(s.length % 2 === 0){
      answer = answer.concat(s[s.length/2 -1]);
      answer = answer.concat(s[s.length/2]);
  } else{
      answer = answer.concat(s[Math.floor(s.length/2)]);
  }
  return answer;
}